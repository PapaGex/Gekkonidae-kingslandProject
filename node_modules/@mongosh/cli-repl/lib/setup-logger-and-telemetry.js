"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mongodb_redact_1 = __importDefault(require("mongodb-redact"));
const history_1 = require("@mongosh/history");
const util_1 = require("util");
const build_info_1 = require("./build-info");
function jsonClone(input) {
    try {
        return JSON.parse(JSON.stringify(input));
    }
    catch (error) {
        return { _inspected: util_1.inspect(input) };
    }
}
class NoopAnalytics {
    identify(_info) { }
    track(_info) { }
}
function setupLoggerAndTelemetry(logId, bus, makeLogger, makeAnalytics) {
    const log = makeLogger();
    const mongosh_version = require('../package.json').version;
    let userId;
    let telemetry;
    const userTraits = {
        platform: process.platform,
        arch: process.arch
    };
    log.info('mongosh:start-logging', {
        execPath: process.execPath,
        ...build_info_1.buildInfo()
    });
    let analytics = new NoopAnalytics();
    try {
        analytics = makeAnalytics();
    }
    catch (e) {
        log.error(e);
    }
    let hasStartedMongoshRepl = false;
    bus.on('mongosh:start-mongosh-repl', (ev) => {
        log.info('mongosh:start-mongosh-repl', ev);
        hasStartedMongoshRepl = true;
    });
    let usesShellOption = false;
    bus.on('mongosh:start-loading-cli-scripts', (event) => {
        log.info('mongosh:start-loading-cli-scripts');
        usesShellOption = event.usesShellOption;
    });
    bus.on('mongosh:connect', function (args) {
        const connectionUri = history_1.redactURICredentials(args.uri);
        const { uri: _uri, ...argsWithoutUri } = args;
        const params = { session_id: logId, userId, connectionUri, ...argsWithoutUri };
        log.info('mongosh:connect', jsonClone(params));
        if (telemetry) {
            analytics.track({
                userId,
                event: 'New Connection',
                properties: {
                    mongosh_version,
                    session_id: logId,
                    ...argsWithoutUri
                }
            });
        }
    });
    bus.on('mongosh:driver-initialized', function (driverMetadata) {
        log.info('mongosh:driver-initialized', jsonClone(driverMetadata));
    });
    bus.on('mongosh:new-user', function (id, enableTelemetry) {
        userId = id;
        telemetry = enableTelemetry;
        if (telemetry)
            analytics.identify({ userId, traits: userTraits });
    });
    bus.on('mongosh:update-user', function (id, enableTelemetry) {
        userId = id;
        telemetry = enableTelemetry;
        if (telemetry)
            analytics.identify({ userId, traits: userTraits });
        log.info('mongosh:update-user', { enableTelemetry });
    });
    bus.on('mongosh:error', function (error) {
        log.error(error);
        if (telemetry && error.name.includes('Mongosh')) {
            analytics.track({
                userId,
                event: 'Error',
                properties: {
                    mongosh_version,
                    name: error.name,
                    code: error.code,
                    scope: error.scope,
                    metadata: error.metadata
                }
            });
        }
    });
    bus.on('mongosh:evaluate-input', function (args) {
        log.info('mongosh:evaluate-input', args);
    });
    bus.on('mongosh:use', function (args) {
        log.info('mongosh:use', args);
        if (telemetry) {
            analytics.track({
                userId,
                event: 'Use',
                properties: {
                    mongosh_version
                }
            });
        }
    });
    bus.on('mongosh:show', function (args) {
        log.info('mongosh:show', args);
        if (telemetry) {
            analytics.track({
                userId,
                event: 'Show',
                properties: {
                    mongosh_version,
                    method: args.method
                }
            });
        }
    });
    bus.on('mongosh:setCtx', function (args) {
        log.info('mongosh:setCtx', jsonClone(args));
    });
    bus.on('mongosh:api-call', function (args) {
        log.info('mongosh:api-call', mongodb_redact_1.default(jsonClone(args)));
    });
    bus.on('mongosh:api-load-file', function (args) {
        log.info('mongosh:api-load-file', args);
        if (telemetry) {
            analytics.track({
                userId,
                event: hasStartedMongoshRepl ? 'Script Loaded' : 'Script Loaded CLI',
                properties: {
                    mongosh_version,
                    nested: args.nested,
                    ...(hasStartedMongoshRepl ? {} : { shell: usesShellOption })
                }
            });
        }
    });
    bus.on('mongosh:eval-cli-script', function () {
        log.info('mongosh:eval-cli-script');
        if (telemetry) {
            analytics.track({
                userId,
                event: 'Script Evaluated',
                properties: {
                    mongosh_version,
                    shell: usesShellOption
                }
            });
        }
    });
    bus.on('mongosh:mongoshrc-load', function () {
        log.info('mongosh:mongoshrc-load');
        if (telemetry) {
            analytics.track({
                userId,
                event: 'Mongoshrc Loaded',
                properties: {
                    mongosh_version
                }
            });
        }
    });
    bus.on('mongosh:mongoshrc-mongorc-warn', function () {
        log.info('mongosh:mongoshrc-mongorc-warn');
        if (telemetry) {
            analytics.track({
                userId,
                event: 'Mongorc Warning',
                properties: {
                    mongosh_version
                }
            });
        }
    });
    bus.on('mongosh:mongocryptd-tryspawn', function (ev) {
        log.info('mongosh:mongocryptd-tryspawn', ev);
    });
    bus.on('mongosh:mongocryptd-error', function (ev) {
        log.error('mongosh:mongocryptd-error', ev);
    });
    bus.on('mongosh:mongocryptd-log', function (ev) {
        log.info('mongosh:mongocryptd-log', ev);
    });
    bus.on('mongosh-snippets:loaded', function (ev) {
        log.info('mongosh-snippets:loaded', ev);
    });
    bus.on('mongosh-snippets:npm-lookup', function (ev) {
        log.info('mongosh-snippets:npm-lookup', ev);
    });
    bus.on('mongosh-snippets:npm-lookup-stopped', function () {
        log.info('mongosh-snippets:npm-lookup-stopped');
    });
    bus.on('mongosh-snippets:npm-download-failed', function (ev) {
        log.error('mongosh-snippets:npm-download-failed', ev);
    });
    bus.on('mongosh-snippets:npm-download-active', function (ev) {
        log.info('mongosh-snippets:npm-download-active', ev);
    });
    bus.on('mongosh-snippets:fetch-index', function (ev) {
        log.info('mongosh-snippets:fetch-index', ev);
    });
    bus.on('mongosh-snippets:fetch-cache-invalid', function () {
        log.info('mongosh-snippets:fetch-cache-invalid');
    });
    bus.on('mongosh-snippets:fetch-index-error', function (ev) {
        log.error('mongosh-snippets:fetch-index-error', ev);
    });
    bus.on('mongosh-snippets:fetch-index-done', function () {
        log.info('mongosh-snippets:fetch-index-done');
    });
    bus.on('mongosh-snippets:package-json-edit-error', function (ev) {
        log.error('mongosh-snippets:package-json-edit-error', ev);
    });
    bus.on('mongosh-snippets:spawn-child', function (ev) {
        log.info('mongosh-snippets:spawn-child', ev);
    });
    bus.on('mongosh-snippets:load-snippet', function (ev) {
        log.info('mongosh-snippets:load-snippet', ev);
    });
    bus.on('mongosh-snippets:snippet-command', function (ev) {
        log.info('mongosh-snippets:snippet-command', ev);
        if (telemetry && ev.args[0] === 'install') {
            analytics.track({
                userId,
                event: 'Snippet Install',
                properties: {
                    mongosh_version
                }
            });
        }
    });
    bus.on('mongosh-snippets:transform-error', function (ev) {
        log.info('mongosh-snippets:transform-error', ev);
    });
    const deprecatedApiCalls = new Set();
    bus.on('mongosh:deprecated-api-call', function (ev) {
        deprecatedApiCalls.add(`${ev.class}#${ev.method}`);
    });
    bus.on('mongosh:evaluate-finished', function () {
        deprecatedApiCalls.forEach(e => {
            const [clazz, method] = e.split('#');
            log.info('mongosh:deprecated-api-call', { class: clazz, method });
            if (telemetry) {
                analytics.track({
                    userId,
                    event: 'Deprecated Method',
                    properties: {
                        mongosh_version,
                        class: clazz,
                        method
                    }
                });
            }
        });
        deprecatedApiCalls.clear();
    });
    bus.on('mongosh-sp:connect-heartbeat-failure', function (ev) {
        var _a;
        log.info('mongosh-sp:connect-heartbeat-failure', {
            ...ev,
            failure: (_a = ev.failure) === null || _a === void 0 ? void 0 : _a.message
        });
    });
    bus.on('mongosh-sp:connect-heartbeat-succeeded', function (ev) {
        log.info('mongosh-sp:connect-heartbeat-succeeded', ev);
    });
    bus.on('mongosh-sp:connect-fail-early', function () {
        log.info('mongosh-sp:connect-fail-early');
    });
    bus.on('mongosh-sp:connect-attempt-finished', function () {
        log.info('mongosh-sp:connect-attempt-finished');
    });
    bus.on('mongosh-sp:resolve-srv-error', function (ev) {
        var _a;
        log.info('mongosh-sp:resolve-srv-error', {
            from: history_1.redactURICredentials(ev.from),
            error: (_a = ev.error) === null || _a === void 0 ? void 0 : _a.message,
            duringLoad: ev.duringLoad
        });
    });
    bus.on('mongosh-sp:resolve-srv-succeeded', function (ev) {
        log.info('mongosh-sp:resolve-srv-succeeded', {
            from: history_1.redactURICredentials(ev.from),
            to: history_1.redactURICredentials(ev.to)
        });
    });
    bus.on('mongosh-sp:reset-connection-options', function () {
        log.info('mongosh-sp:reset-connection-options');
    });
    bus.on('mongosh-sp:missing-optional-dependency', function (ev) {
        log.info('mongosh-sp:missing-optional-dependency', { name: ev.name, error: ev === null || ev === void 0 ? void 0 : ev.error.message });
    });
}
exports.default = setupLoggerAndTelemetry;
//# sourceMappingURL=setup-logger-and-telemetry.js.map